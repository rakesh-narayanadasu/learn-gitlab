# Caching in GitLab CI/CD
A cache is one or more files a job downloads and saves. Subsequent jobs that use the same cache don’t have to download the files again, so they execute more quickly.

# How cache is different from artifacts
Use cache for dependencies, like packages you download from the internet. Cache is stored where GitLab Runner is installed and uploaded to S3 if distributed cache is enabled.

Use artifacts to pass intermediate build results between stages. Artifacts are generated by a job, stored in GitLab, and can be downloaded.

Both artifacts and caches define their paths relative to the project directory, and can’t link to files outside it.

# cache
Use cache to specify a list of files and directories to cache between jobs. You can only use paths that are in the local working copy.
Caches are:
* Shared between pipelines and jobs.
* By default, not shared between protected and unprotected branches.
* Restored before artifacts.
* Limited to a maximum of four different caches.

# cache:paths
Use the ```cache:paths``` keyword to choose which files or directories to cache.

* You need to define the path which needs to be cached, it could be single file or array of files or directories
* The ```cache:paths``` keyword includes files even if they are untracked or in your ```.gitignore``` file.

# cache:key
Use the ```cache:key``` keyword to give each cache a unique identifying key. All jobs that use the same cache key use the same cache, including in different pipelines. 
* Key gives unique key for each cache So multiple jobs using the same cache key uses the same cache. So as long as the key is same, it's going to download the same cache and use it across jobs or across the pipelines.

```sh
code_coverage:
  stage: test
  image: node:17-alpine3.14
  cache:
    policy: pull-push
    when: on_success
    paths:
      - node_modules  #what files to cache
    key:  #This example creates a cache for Node.js dependencies. The cache is tied to the current versions of the and package-lock.json files. When the file changes, a new cache key is computed and a new cache is created. Any future job runs that use the same package.json with cache:key:files use the new cache, instead of rebuilding the dependencies.
      files:
        - package-lock.json
      prefix: node_modules
```

# cache:key:prefix
Use ```cache:key:prefix``` to combine a prefix with the SHA computed for ```cache:key:files```.
```sh
rspec:
  script:
    - echo "This rspec job uses a cache."
  cache:
    key:
      files:
        - Gemfile.lock
      prefix: $CI_JOB_NAME
    paths:
      - vendor/ruby

```

# cache:policy
To change the upload and download behavior of a cache, use the ```cache:policy``` keyword. By default, the job downloads the cache when the job starts, and uploads changes to the cache when the job ends. This caching style is the ```pull-push``` policy (default).
* policy defines what the job has to do in case of a cache. Does it require to download the cache or upload the cache?

To set a job to only download the cache when the job starts, but never upload changes when the job finishes, use ```cache:policy:pull```.

To set a job to only upload a cache when the job finishes, but never download the cache when the job starts, use ```cache:policy:push```.